package cryptography

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/des"
	"encoding/base64"
	"fmt"
	log "github.com/sirupsen/logrus"
	"os"
	"strings"

	"golang.org/x/crypto/blowfish"
)

// Supported cipher types
const (
	AES_CBC  = "AES/CBC/PKCS5Padding"
	AES_ECB  = "AES/ECB/PKCS5Padding"
	DES_CBC  = "DES/CBC/PKCS5Padding"
	DES_EDE3 = "DESede/CBC/PKCS5Padding"
	BLOWFISH = "Blowfish/CBC/PKCS5Padding"
)

type NewCipherBlockFunc func(key []byte) (cipher.Block, error)

type DecryptionModeFunc func(block cipher.Block, plainTextBlock []byte) []byte

type CipherAlgorithm struct {
	NewCipherBlockFuncPtr NewCipherBlockFunc
	DecryptionModeFuncPtr DecryptionModeFunc
}

type KeyVault struct {
	CipherAlgorithm CipherAlgorithm
	CipherBlock     cipher.Block
}

var cipherAlgorithms = map[string]CipherAlgorithm{
	AES_CBC: {
		NewCipherBlockFuncPtr: aes.NewCipher,
		DecryptionModeFuncPtr: decryptUsingCbc,
	},
	AES_ECB: {
		NewCipherBlockFuncPtr: aes.NewCipher,
		DecryptionModeFuncPtr: decryptUsingEcb,
	},
	DES_CBC: {
		NewCipherBlockFuncPtr: des.NewCipher,
		DecryptionModeFuncPtr: decryptUsingCbc,
	},
	DES_EDE3: {
		NewCipherBlockFuncPtr: des.NewTripleDESCipher,
		DecryptionModeFuncPtr: decryptUsingCbc,
	},
	BLOWFISH: {
		NewCipherBlockFuncPtr: BlowfishNewCipherWrapper,
		DecryptionModeFuncPtr: decryptUsingCbc,
	},
}

// BlowfishNewCipherWrapper
//
//	Need to have a wrapper function for the Blowfish cipher as it returns a Cipher object which needs to be cast to a
//	cipher.Block interface.
func BlowfishNewCipherWrapper(key []byte) (cipher.Block, error) {
	return blowfish.NewCipher(key)
}

func NewKeyVault(keyFilePath string) (*KeyVault, error) {
	key, cipherType, err := readKeyAndCipherType(keyFilePath)

	if err != nil {
		return nil, err
	}

	cipherAlgorithmVal, ok := cipherAlgorithms[cipherType]
	if !ok {
		return nil, fmt.Errorf("unsupported cipher type: %s", cipherType)
	}

	cipherBlock, err := cipherAlgorithmVal.NewCipherBlockFuncPtr(key)
	if err != nil {
		return nil, err
	}

	log.Info("Encryption key vault created; assuming all passwords are encrypted")

	return &KeyVault{
		CipherAlgorithm: cipherAlgorithmVal,
		CipherBlock:     cipherBlock,
	}, nil

}

func readKeyAndCipherType(filePath string) ([]byte, string, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, "", err
	}

	// Split the data into cipher type and key
	parts := strings.SplitN(string(data), ":", 2)
	lenParts := len(parts)
	if lenParts < 2 && lenParts > 3 {
		return nil, "", fmt.Errorf("invalid key file format")
	}

	var keyBase64 string
	cipherType := parts[0]
	if lenParts == 2 {
		keyBase64 = parts[1]
	} else {
		// Handle keys generated by dsetool
		keyBase64 = parts[2]
	}

	// Decode the base64 encoded key
	key, err := base64.StdEncoding.DecodeString(keyBase64)
	if err != nil {
		return nil, "", fmt.Errorf("failed to decode key: %v", err)
	}

	return key, cipherType, nil
}

func (kv *KeyVault) Decrypt(encryptedData string) (string, error) {
	// Decode the base64 encoded encrypted value
	encryptedDecodedData, err := base64.StdEncoding.DecodeString(encryptedData)
	if err != nil {
		return "", fmt.Errorf("failed to decode encrypted value: %v", err)
	}

	decryptedData := kv.CipherAlgorithm.DecryptionModeFuncPtr(kv.CipherBlock, encryptedDecodedData)
	decryptedData, err = pkcs5Unpadding(kv.CipherBlock, decryptedData)
	if err != nil {
		return "", err
	}

	return string(decryptedData), err
}

func decryptUsingCbc(block cipher.Block, encryptedData []byte) []byte {
	iv := encryptedData[:block.BlockSize()]
	data := encryptedData[block.BlockSize():]
	mode := cipher.NewCBCDecrypter(block, iv)
	decryptedData := make([]byte, len(data))
	mode.CryptBlocks(decryptedData, data)
	return decryptedData
}

func decryptUsingEcb(block cipher.Block, encryptedData []byte) []byte {
	decryptedData := make([]byte, len(encryptedData))
	for bs, be := 0, block.BlockSize(); bs < len(encryptedData); bs, be = bs+block.BlockSize(), be+block.BlockSize() {
		block.Decrypt(decryptedData[bs:be], encryptedData[bs:be])
	}
	return decryptedData
}

func pkcs5Unpadding(block cipher.Block, data []byte) ([]byte, error) {
	length := len(data)
	if length == 0 {
		return nil, fmt.Errorf("data is empty")
	}
	unpadding := int(data[length-1])
	unpaddingCount := unpadding

	// Validate the padding bytes at the end of the data. If it is less than the block size, then check if the value is
	// a padding size or part of the decoded data. The padding value will be repeated the number of times equal to the
	// padding size. E.g. If the padding value is 7, then the last 7 bytes of the data should all be the value 7.
	if unpadding > 0 && unpadding < block.BlockSize() {
		for i := length - 1; i >= length-unpadding; i-- {
			if int(data[i]) == unpadding {
				unpaddingCount--
			} else {
				break
			}
		}
	}

	if unpaddingCount > 0 {
		unpadding = 0
	}

	return data[:(length - unpadding)], nil
}
